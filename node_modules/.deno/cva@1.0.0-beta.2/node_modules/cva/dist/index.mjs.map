{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;CAcC,GACD,SAAS,IAAI,QAAQ,OAAO;AAgJ5B;+CAC+C,GAE/C,MAAM,gBAAgB,CAAoB,QACxC,OAAO,UAAU,YAAY,CAAC,EAAE,MAAM,CAAC,GAAG,UAAU,IAAI,MAAM;AAEhE,OAAO,MAAM,eAA6B,CAAC;IACzC,MAAM,KAAS;yCAAI;YAAA;;YACN,gBAGA;QAHX,IAAI,QAAO,oBAAA,+BAAA,iBAAA,QAAS,KAAK,cAAd,qCAAA,cAAgB,CAAC,UAAU,MAAK,aACzC,OAAO,oBAAA,8BAAA,QAAS,KAAK,CAAC,UAAU,CAAC,KAAK;QAExC,IAAI,QAAO,oBAAA,+BAAA,kBAAA,QAAS,KAAK,cAAd,sCAAA,gBAAgB,UAAU,MAAK,aACxC,OAAO,oBAAA,8BAAA,QAAS,KAAK,CAAC,UAAU,CAAC,KAAK;QAExC,OAAO,KAAK;IACd;IAEA,MAAM,MAAW,CAAC,SAAW,CAAC;gBA+BS;YA9BrC,IAAI,CAAA,mBAAA,6BAAA,OAAQ,QAAQ,KAAI,MACtB,OAAO,GAAG,mBAAA,6BAAA,OAAQ,IAAI,EAAE,kBAAA,4BAAA,MAAO,KAAK,EAAE,kBAAA,4BAAA,MAAO,SAAS;YAExD,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG;YAEtC,MAAM,uBAAuB,OAAO,IAAI,CAAC,UAAU,GAAG,CACpD,CAAC;gBACC,MAAM,cAAc,kBAAA,4BAAA,KAAO,CAAC,QAA8B;gBAC1D,MAAM,qBAAqB,4BAAA,sCAAA,eAAiB,CAAC,QAAQ;gBAErD,MAAM,aAAc,cAAc,gBAChC,cACE;gBAGJ,OAAO,QAAQ,CAAC,QAAQ,CAAC,WAAW;YACtC;YAGF,MAAM,mBAAmB;gBACvB,GAAG,eAAe;gBAClB,2BAA2B;gBAC3B,GAAI,SACF,OAAO,OAAO,CAAC,OAAO,MAAM,CAC1B,CAAC;wBAAK,CAAC,KAAK,MAAM;2BAChB,OAAO,UAAU,cAAc,MAAM;wBAAE,GAAG,GAAG;wBAAE,CAAC,IAAI,EAAE;oBAAM;mBAC9D,CAAC,EACF;YACL;YAEA,MAAM,+BAA+B,mBAAA,8BAAA,2BAAA,OAAQ,gBAAgB,cAAxB,+CAAA,yBAA0B,MAAM,CACnE,CAAC;oBAAK,EAAE,OAAO,OAAO,EAAE,WAAW,WAAW,EAAE,GAAG,UAAU;uBAC3D,OAAO,OAAO,CAAC,UAAU,KAAK,CAAC;wBAAC,CAAC,OAAO,WAAW;oBACjD,MAAM,WACJ,gBAAgB,CAAC,MAAuC;oBAE1D,OAAO,MAAM,OAAO,CAAC,cACjB,WAAW,QAAQ,CAAC,YACpB,aAAa;gBACnB,KACI;uBAAI;oBAAK;oBAAS;iBAAY,GAC9B;eACN,EAAE;YAGJ,OAAO,GACL,mBAAA,6BAAA,OAAQ,IAAI,EACZ,sBACA,8BACA,kBAAA,4BAAA,MAAO,KAAK,EACZ,kBAAA,4BAAA,MAAO,SAAS;QAEpB;IAEA,MAAM,UACJ;yCAAI;YAAA;;eACJ,CAAC;YACC,MAAM,oBAAoB,OAAO,WAAW,CAC1C,OAAO,OAAO,CAAC,SAAS,CAAC,GAAG,MAAM,CAChC;oBAAC,CAAC,IAAI;uBAAK,CAAC;oBAAC;oBAAS;iBAAY,CAAC,QAAQ,CAAC;;YAIhD,OAAO,GACL,WAAW,GAAG,CAAC,CAAC,YAAc,UAAU,qBACxC,kBAAA,4BAAA,MAAO,KAAK,EACZ,kBAAA,4BAAA,MAAO,SAAS;QAEpB;;IAEF,OAAO;QACL;QACA;QACA;IACF;AACF,EAAE;AAEF,OAAO,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,eAAe","file":"index.mjs","sourcesContent":["/**\n * Copyright 2022 Joe Bell. All rights reserved.\n *\n * This file is licensed to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\nimport { clsx } from \"clsx\";\n\n/* Types\n  ============================================ */\n\n/* clsx\n  ---------------------------------- */\n\n// When compiling with `declaration: true`, many projects experience the dreaded\n// TS2742 error. To combat this, we copy clsx's types manually.\n// Should this project move to JSDoc, this workaround would no longer be needed.\n\ntype ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\ntype ClassDictionary = Record<string, any>;\ntype ClassArray = ClassValue[];\n\n/* Utils\n  ---------------------------------- */\n\ntype OmitUndefined<T> = T extends undefined ? never : T;\ntype StringToBoolean<T> = T extends \"true\" | \"false\" ? boolean : T;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\nexport type VariantProps<Component extends (...args: any) => any> = Omit<\n  OmitUndefined<Parameters<Component>[0]>,\n  \"class\" | \"className\"\n>;\n\n/* compose\n  ---------------------------------- */\n\nexport interface Compose {\n  <T extends ReturnType<CVA>[]>(\n    ...components: [...T]\n  ): (\n    props?: (\n      | UnionToIntersection<\n          {\n            [K in keyof T]: VariantProps<T[K]>;\n          }[number]\n        >\n      | undefined\n    ) &\n      CVAClassProp,\n  ) => string;\n}\n\n/* cx\n  ---------------------------------- */\n\nexport interface CX {\n  (...inputs: ClassValue[]): string;\n}\n\nexport type CXOptions = Parameters<CX>;\nexport type CXReturn = ReturnType<CX>;\n\n/* cva\n  ============================================ */\n\ntype CVAConfigBase = { base?: ClassValue };\ntype CVAVariantShape = Record<string, Record<string, ClassValue>>;\ntype CVAVariantSchema<V extends CVAVariantShape> = {\n  [Variant in keyof V]?: StringToBoolean<keyof V[Variant]> | undefined;\n};\ntype CVAClassProp =\n  | {\n      class?: ClassValue;\n      className?: never;\n    }\n  | {\n      class?: never;\n      className?: ClassValue;\n    };\n\nexport interface CVA {\n  <\n    _ extends \"cva's generic parameters are restricted to internal use only.\",\n    V,\n  >(\n    config: V extends CVAVariantShape\n      ? CVAConfigBase & {\n          variants?: V;\n          compoundVariants?: (V extends CVAVariantShape\n            ? (\n                | CVAVariantSchema<V>\n                | {\n                    [Variant in keyof V]?:\n                      | StringToBoolean<keyof V[Variant]>\n                      | StringToBoolean<keyof V[Variant]>[]\n                      | undefined;\n                  }\n              ) &\n                CVAClassProp\n            : CVAClassProp)[];\n          defaultVariants?: CVAVariantSchema<V>;\n        }\n      : CVAConfigBase & {\n          variants?: never;\n          compoundVariants?: never;\n          defaultVariants?: never;\n        },\n  ): (\n    props?: V extends CVAVariantShape\n      ? CVAVariantSchema<V> & CVAClassProp\n      : CVAClassProp,\n  ) => string;\n}\n\n/* defineConfig\n  ---------------------------------- */\n\nexport interface DefineConfigOptions {\n  hooks?: {\n    /**\n     * @deprecatedÂ please use `onComplete`\n     */\n    \"cx:done\"?: (className: string) => string;\n    /**\n     * Returns the completed string of concatenated classes/classNames.\n     */\n    onComplete?: (className: string) => string;\n  };\n}\n\nexport interface DefineConfig {\n  (options?: DefineConfigOptions): {\n    compose: Compose;\n    cx: CX;\n    cva: CVA;\n  };\n}\n\n/* Exports\n  ============================================ */\n\nconst falsyToString = <T extends unknown>(value: T) =>\n  typeof value === \"boolean\" ? `${value}` : value === 0 ? \"0\" : value;\n\nexport const defineConfig: DefineConfig = (options) => {\n  const cx: CX = (...inputs) => {\n    if (typeof options?.hooks?.[\"cx:done\"] !== \"undefined\")\n      return options?.hooks[\"cx:done\"](clsx(inputs));\n\n    if (typeof options?.hooks?.onComplete !== \"undefined\")\n      return options?.hooks.onComplete(clsx(inputs));\n\n    return clsx(inputs);\n  };\n\n  const cva: CVA = (config) => (props) => {\n    if (config?.variants == null)\n      return cx(config?.base, props?.class, props?.className);\n\n    const { variants, defaultVariants } = config;\n\n    const getVariantClassNames = Object.keys(variants).map(\n      (variant: keyof typeof variants) => {\n        const variantProp = props?.[variant as keyof typeof props];\n        const defaultVariantProp = defaultVariants?.[variant];\n\n        const variantKey = (falsyToString(variantProp) ||\n          falsyToString(\n            defaultVariantProp,\n          )) as keyof (typeof variants)[typeof variant];\n\n        return variants[variant][variantKey];\n      },\n    );\n\n    const defaultsAndProps = {\n      ...defaultVariants,\n      // remove `undefined` props\n      ...(props &&\n        Object.entries(props).reduce<typeof props>(\n          (acc, [key, value]) =>\n            typeof value === \"undefined\" ? acc : { ...acc, [key]: value },\n          {} as typeof props,\n        )),\n    };\n\n    const getCompoundVariantClassNames = config?.compoundVariants?.reduce(\n      (acc, { class: cvClass, className: cvClassName, ...cvConfig }) =>\n        Object.entries(cvConfig).every(([cvKey, cvSelector]) => {\n          const selector =\n            defaultsAndProps[cvKey as keyof typeof defaultsAndProps];\n\n          return Array.isArray(cvSelector)\n            ? cvSelector.includes(selector)\n            : selector === cvSelector;\n        })\n          ? [...acc, cvClass, cvClassName]\n          : acc,\n      [] as ClassValue[],\n    );\n\n    return cx(\n      config?.base,\n      getVariantClassNames,\n      getCompoundVariantClassNames,\n      props?.class,\n      props?.className,\n    );\n  };\n\n  const compose: Compose =\n    (...components) =>\n    (props) => {\n      const propsWithoutClass = Object.fromEntries(\n        Object.entries(props || {}).filter(\n          ([key]) => ![\"class\", \"className\"].includes(key),\n        ),\n      );\n\n      return cx(\n        components.map((component) => component(propsWithoutClass)),\n        props?.class,\n        props?.className,\n      );\n    };\n\n  return {\n    compose,\n    cva,\n    cx,\n  };\n};\n\nexport const { compose, cva, cx } = defineConfig();\n"]}