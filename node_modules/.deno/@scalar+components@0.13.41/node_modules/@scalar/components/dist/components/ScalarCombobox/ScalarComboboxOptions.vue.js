import { defineComponent as O, useId as q, computed as b, ref as D, onMounted as F, watch as G, openBlock as c, createElementBlock as y, Fragment as $, createElementVNode as w, createVNode as U, unref as j, withDirectives as C, withKeys as x, withModifiers as h, vModelText as H, renderSlot as S, renderList as B, createBlock as M, withCtx as V, createTextVNode as E, toDisplayString as N, normalizeStyle as J, createCommentVNode as P, vShow as Q } from "vue";
import R from "./ScalarComboboxOption.vue.js";
import W from "./ScalarComboboxOptionGroup.vue.js";
import { isGroups as L } from "./types.js";
import X from "../ScalarIcon/ScalarIcon.vue.js";
const Y = { class: "relative flex" }, Z = ["aria-activedescendant", "placeholder"], _ = ["aria-multiselectable"], ne = /* @__PURE__ */ O({
  inheritAttrs: !1,
  __name: "ScalarComboboxOptions",
  props: {
    options: {},
    modelValue: {},
    placeholder: {},
    multiselect: { type: Boolean },
    isDeletable: { type: Boolean }
  },
  emits: ["update:modelValue", "delete"],
  setup(T, { emit: z }) {
    var I;
    const a = T, A = z, m = `scalar-combobox-items-${q()}`;
    function p(e) {
      return `${m}-${e.id}`;
    }
    const f = b(
      () => L(a.options) ? a.options.flatMap((e) => e.options) : a.options
    ), K = b(
      () => L(a.options) ? a.options : [{ label: "", options: a.options }]
    ), r = D(""), o = D(
      ((I = a.modelValue) == null ? void 0 : I[0]) ?? f.value[0]
    );
    F(async () => {
      var e;
      r.value = "", o.value = ((e = a.modelValue) == null ? void 0 : e[0]) ?? f.value[0], s.value.length !== 0 && setTimeout(() => {
        var t;
        (t = document == null ? void 0 : document.getElementById(p(s.value[0]))) == null || t.scrollIntoView({ block: "nearest" });
      }, 10);
    }), G(
      () => r.value,
      () => o.value = v.value[0]
    );
    const v = b(
      () => r.value === "" ? f.value : f.value.filter((e) => e.label.toLowerCase().includes(r.value.toLowerCase()))
    ), s = b({
      get: () => a.modelValue ?? [],
      set: (e) => e && A("update:modelValue", e)
    });
    function g(e) {
      a.multiselect ? s.value.some((t) => t.id === e.id) ? s.value = s.value.filter((t) => t.id !== e.id) : s.value = [...s.value, e] : s.value = [e];
    }
    function k(e) {
      var l;
      const t = v.value, d = t.findIndex((u) => {
        var i;
        return u.id === ((i = o.value) == null ? void 0 : i.id);
      }) + e;
      d < 0 || d > t.length - 1 || (o.value = t[d], (l = document == null ? void 0 : document.getElementById(p(o.value))) == null || l.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      }));
    }
    return (e, t) => (c(), y($, null, [
      w("div", Y, [
        U(j(X), {
          class: "pointer-events-none absolute left-2.5 top-1/2 -translate-y-1/2 text-c-3",
          icon: "Search",
          size: "md"
        }),
        C(w("input", {
          "onUpdate:modelValue": t[0] || (t[0] = (n) => r.value = n),
          "aria-activedescendant": o.value ? p(o.value) : void 0,
          "aria-autocomplete": "list",
          "aria-controls": m,
          class: "min-w-0 flex-1 rounded border-0 py-2.5 pl-8 pr-3 leading-none text-c-1 -outline-offset-1",
          "data-1p-ignore": "",
          placeholder: e.placeholder,
          role: "combobox",
          tabindex: "0",
          type: "text",
          onKeydown: [
            t[1] || (t[1] = x(h((n) => k(1), ["prevent"]), ["down"])),
            t[2] || (t[2] = x(h((n) => o.value && g(o.value), ["prevent"]), ["enter"])),
            t[3] || (t[3] = x(h((n) => k(-1), ["prevent"]), ["up"]))
          ]
        }, null, 40, Z), [
          [H, r.value]
        ])
      ]),
      C(w("ul", {
        id: m,
        "aria-multiselectable": e.multiselect,
        class: "border-t p-0.75 custom-scroll overscroll-contain flex-1 min-h-0",
        role: "listbox",
        tabindex: "-1"
      }, [
        S(e.$slots, "before"),
        (c(!0), y($, null, B(K.value, (n, d) => (c(), M(W, {
          id: `${m}-group-${d}`,
          key: d,
          hidden: (
            // Only show the group label if there are some results
            !n.options.some((l) => v.value.some((u) => u.id === l.id)) || // And it has a label
            !n.label
          )
        }, {
          label: V(() => [
            E(N(n.label), 1)
          ]),
          default: V(() => [
            (c(!0), y($, null, B(v.value, (l) => {
              var u;
              return c(), y($, {
                key: l.id
              }, [
                n.options.some((i) => i.id === l.id) ? (c(), M(R, {
                  key: 0,
                  id: p(l),
                  active: ((u = o.value) == null ? void 0 : u.id) === l.id,
                  isDeletable: l.isDeletable ?? e.isDeletable,
                  selected: s.value.some((i) => i.id === l.id),
                  style: J(e.multiselect ? "checkbox" : "radio"),
                  onClick: (i) => g(l),
                  onDelete: (i) => e.$emit("delete", l),
                  onMousedown: t[4] || (t[4] = h(() => {
                  }, ["prevent"])),
                  onMouseenter: (i) => o.value = l
                }, {
                  default: V(() => [
                    E(N(l.label), 1)
                  ]),
                  _: 2
                }, 1032, ["id", "active", "isDeletable", "selected", "style", "onClick", "onDelete", "onMouseenter"])) : P("", !0)
              ], 64);
            }), 128))
          ]),
          _: 2
        }, 1032, ["id", "hidden"]))), 128)),
        S(e.$slots, "after")
      ], 8, _), [
        [Q, v.value.length || e.$slots.before || e.$slots.after]
      ])
    ], 64));
  }
});
export {
  ne as default
};
