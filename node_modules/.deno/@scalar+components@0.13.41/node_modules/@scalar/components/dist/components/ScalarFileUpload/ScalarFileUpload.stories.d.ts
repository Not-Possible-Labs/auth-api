import type { StoryObj } from '@storybook/vue3';
declare const meta: {
    component: {
        new (...args: any[]): import("vue").CreateComponentPublicInstanceWithMixins<Readonly<{
            modelValue?: File[];
            error?: string;
        } & {
            multiple?: boolean;
            accept?: import("./types").ExtensionList | string;
            loader?: import("../ScalarLoading").LoadingState;
            variant?: "compact" | "default";
        }> & Readonly<{
            "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
            onSelected?: ((value: File[]) => any) | undefined;
            "onUpdate:error"?: ((value: string) => any) | undefined;
        }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
            "update:modelValue": (value: File[]) => any;
            "update:error": (value: string) => any;
        } & {
            selected: (value: File[]) => any;
        }, import("vue").PublicProps, {}, false, {}, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, {}, any, import("vue").ComponentProvideOptions, {
            P: {};
            B: {};
            D: {};
            C: {};
            M: {};
            Defaults: {};
        }, Readonly<{
            modelValue?: File[];
            error?: string;
        } & {
            multiple?: boolean;
            accept?: import("./types").ExtensionList | string;
            loader?: import("../ScalarLoading").LoadingState;
            variant?: "compact" | "default";
        }> & Readonly<{
            "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
            onSelected?: ((value: File[]) => any) | undefined;
            "onUpdate:error"?: ((value: string) => any) | undefined;
        }>, {}, {}, {}, {}, {}>;
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("vue").ComponentOptionsBase<Readonly<{
        modelValue?: File[];
        error?: string;
    } & {
        multiple?: boolean;
        accept?: import("./types").ExtensionList | string;
        loader?: import("../ScalarLoading").LoadingState;
        variant?: "compact" | "default";
    }> & Readonly<{
        "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
        onSelected?: ((value: File[]) => any) | undefined;
        "onUpdate:error"?: ((value: string) => any) | undefined;
    }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
        "update:modelValue": (value: File[]) => any;
        "update:error": (value: string) => any;
    } & {
        selected: (value: File[]) => any;
    }, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & (new () => {
        $slots: Readonly<{
            default?: (props: {
                open: () => void;
            }) => any;
            label?: () => any;
            'drop-target'?: () => any;
            'drop-target-label'?: () => any;
        }> & {
            default?: (props: {
                open: () => void;
            }) => any;
            label?: () => any;
            'drop-target'?: () => any;
            'drop-target-label'?: () => any;
        };
    });
    tags: string[];
    argTypes: {
        class: {
            control: "text";
        };
        accept: {
            control: "select";
            options: string[][];
        };
        variant: {
            control: "select";
            options: string[];
        };
    };
    render: (args: import("@storybook/vue3").ComponentPropsAndSlots<{
        new (...args: any[]): import("vue").CreateComponentPublicInstanceWithMixins<Readonly<{
            modelValue?: File[];
            error?: string;
        } & {
            multiple?: boolean;
            accept?: import("./types").ExtensionList | string;
            loader?: import("../ScalarLoading").LoadingState;
            variant?: "compact" | "default";
        }> & Readonly<{
            "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
            onSelected?: ((value: File[]) => any) | undefined;
            "onUpdate:error"?: ((value: string) => any) | undefined;
        }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
            "update:modelValue": (value: File[]) => any;
            "update:error": (value: string) => any;
        } & {
            selected: (value: File[]) => any;
        }, import("vue").PublicProps, {}, false, {}, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, {}, any, import("vue").ComponentProvideOptions, {
            P: {};
            B: {};
            D: {};
            C: {};
            M: {};
            Defaults: {};
        }, Readonly<{
            modelValue?: File[];
            error?: string;
        } & {
            multiple?: boolean;
            accept?: import("./types").ExtensionList | string;
            loader?: import("../ScalarLoading").LoadingState;
            variant?: "compact" | "default";
        }> & Readonly<{
            "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
            onSelected?: ((value: File[]) => any) | undefined;
            "onUpdate:error"?: ((value: string) => any) | undefined;
        }>, {}, {}, {}, {}, {}>;
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("vue").ComponentOptionsBase<Readonly<{
        modelValue?: File[];
        error?: string;
    } & {
        multiple?: boolean;
        accept?: import("./types").ExtensionList | string;
        loader?: import("../ScalarLoading").LoadingState;
        variant?: "compact" | "default";
    }> & Readonly<{
        "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
        onSelected?: ((value: File[]) => any) | undefined;
        "onUpdate:error"?: ((value: string) => any) | undefined;
    }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
        "update:modelValue": (value: File[]) => any;
        "update:error": (value: string) => any;
    } & {
        selected: (value: File[]) => any;
    }, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & (new () => {
        $slots: Readonly<{
            default?: (props: {
                open: () => void;
            }) => any;
            label?: () => any;
            'drop-target'?: () => any;
            'drop-target-label'?: () => any;
        }> & {
            default?: (props: {
                open: () => void;
            }) => any;
            label?: () => any;
            'drop-target'?: () => any;
            'drop-target-label'?: () => any;
        };
    })>) => {
        components: {
            ScalarFileUpload: {
                new (...args: any[]): import("vue").CreateComponentPublicInstanceWithMixins<Readonly<{
                    modelValue?: File[];
                    error?: string;
                } & {
                    multiple?: boolean;
                    accept?: import("./types").ExtensionList | string;
                    loader?: import("../ScalarLoading").LoadingState;
                    variant?: "compact" | "default";
                }> & Readonly<{
                    "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                    onSelected?: ((value: File[]) => any) | undefined;
                    "onUpdate:error"?: ((value: string) => any) | undefined;
                }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
                    "update:modelValue": (value: File[]) => any;
                    "update:error": (value: string) => any;
                } & {
                    selected: (value: File[]) => any;
                }, import("vue").PublicProps, {}, false, {}, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, {}, any, import("vue").ComponentProvideOptions, {
                    P: {};
                    B: {};
                    D: {};
                    C: {};
                    M: {};
                    Defaults: {};
                }, Readonly<{
                    modelValue?: File[];
                    error?: string;
                } & {
                    multiple?: boolean;
                    accept?: import("./types").ExtensionList | string;
                    loader?: import("../ScalarLoading").LoadingState;
                    variant?: "compact" | "default";
                }> & Readonly<{
                    "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                    onSelected?: ((value: File[]) => any) | undefined;
                    "onUpdate:error"?: ((value: string) => any) | undefined;
                }>, {}, {}, {}, {}, {}>;
                __isFragment?: never;
                __isTeleport?: never;
                __isSuspense?: never;
            } & import("vue").ComponentOptionsBase<Readonly<{
                modelValue?: File[];
                error?: string;
            } & {
                multiple?: boolean;
                accept?: import("./types").ExtensionList | string;
                loader?: import("../ScalarLoading").LoadingState;
                variant?: "compact" | "default";
            }> & Readonly<{
                "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                onSelected?: ((value: File[]) => any) | undefined;
                "onUpdate:error"?: ((value: string) => any) | undefined;
            }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
                "update:modelValue": (value: File[]) => any;
                "update:error": (value: string) => any;
            } & {
                selected: (value: File[]) => any;
            }, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & (new () => {
                $slots: Readonly<{
                    default?: (props: {
                        open: () => void;
                    }) => any;
                    label?: () => any;
                    'drop-target'?: () => any;
                    'drop-target-label'?: () => any;
                }> & {
                    default?: (props: {
                        open: () => void;
                    }) => any;
                    label?: () => any;
                    'drop-target'?: () => any;
                    'drop-target-label'?: () => any;
                };
            });
            ScalarFileUploadFileList: import("vue").DefineComponent<{
                modelValue?: File[];
            }, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
                "update:modelValue": (value: File[]) => any;
            } & {
                upload: () => any;
            }, string, import("vue").PublicProps, Readonly<{
                modelValue?: File[];
            }> & Readonly<{
                "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                onUpload?: (() => any) | undefined;
            }>, {}, {}, {}, {}, string, import("vue").ComponentProvideOptions, false, {}, any>;
        };
        setup(this: void): {
            args: import("@storybook/vue3").ComponentPropsAndSlots<{
                new (...args: any[]): import("vue").CreateComponentPublicInstanceWithMixins<Readonly<{
                    modelValue?: File[];
                    error?: string;
                } & {
                    multiple?: boolean;
                    accept?: import("./types").ExtensionList | string;
                    loader?: import("../ScalarLoading").LoadingState;
                    variant?: "compact" | "default";
                }> & Readonly<{
                    "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                    onSelected?: ((value: File[]) => any) | undefined;
                    "onUpdate:error"?: ((value: string) => any) | undefined;
                }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
                    "update:modelValue": (value: File[]) => any;
                    "update:error": (value: string) => any;
                } & {
                    selected: (value: File[]) => any;
                }, import("vue").PublicProps, {}, false, {}, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, {}, any, import("vue").ComponentProvideOptions, {
                    P: {};
                    B: {};
                    D: {};
                    C: {};
                    M: {};
                    Defaults: {};
                }, Readonly<{
                    modelValue?: File[];
                    error?: string;
                } & {
                    multiple?: boolean;
                    accept?: import("./types").ExtensionList | string;
                    loader?: import("../ScalarLoading").LoadingState;
                    variant?: "compact" | "default";
                }> & Readonly<{
                    "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                    onSelected?: ((value: File[]) => any) | undefined;
                    "onUpdate:error"?: ((value: string) => any) | undefined;
                }>, {}, {}, {}, {}, {}>;
                __isFragment?: never;
                __isTeleport?: never;
                __isSuspense?: never;
            } & import("vue").ComponentOptionsBase<Readonly<{
                modelValue?: File[];
                error?: string;
            } & {
                multiple?: boolean;
                accept?: import("./types").ExtensionList | string;
                loader?: import("../ScalarLoading").LoadingState;
                variant?: "compact" | "default";
            }> & Readonly<{
                "onUpdate:modelValue"?: ((value: File[]) => any) | undefined;
                onSelected?: ((value: File[]) => any) | undefined;
                "onUpdate:error"?: ((value: string) => any) | undefined;
            }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
                "update:modelValue": (value: File[]) => any;
                "update:error": (value: string) => any;
            } & {
                selected: (value: File[]) => any;
            }, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & (new () => {
                $slots: Readonly<{
                    default?: (props: {
                        open: () => void;
                    }) => any;
                    label?: () => any;
                    'drop-target'?: () => any;
                    'drop-target-label'?: () => any;
                }> & {
                    default?: (props: {
                        open: () => void;
                    }) => any;
                    label?: () => any;
                    'drop-target'?: () => any;
                    'drop-target-label'?: () => any;
                };
            })>;
            files: import("vue").Ref<{
                readonly lastModified: number;
                readonly name: string;
                readonly webkitRelativePath: string;
                readonly size: number;
                readonly type: string;
                arrayBuffer: () => Promise<ArrayBuffer>;
                slice: (start?: number, end?: number, contentType?: string) => Blob;
                stream: () => ReadableStream<Uint8Array>;
                text: () => Promise<string>;
            }[], File[] | {
                readonly lastModified: number;
                readonly name: string;
                readonly webkitRelativePath: string;
                readonly size: number;
                readonly type: string;
                arrayBuffer: () => Promise<ArrayBuffer>;
                slice: (start?: number, end?: number, contentType?: string) => Blob;
                stream: () => ReadableStream<Uint8Array>;
                text: () => Promise<string>;
            }[]>;
        };
        template: string;
    };
};
export default meta;
type Story = StoryObj<typeof meta>;
export declare const Base: Story;
export declare const Compact: Story;
export declare const Files: Story;
export declare const Loading: Story;
export declare const Labelled: Story;
//# sourceMappingURL=ScalarFileUpload.stories.d.ts.map