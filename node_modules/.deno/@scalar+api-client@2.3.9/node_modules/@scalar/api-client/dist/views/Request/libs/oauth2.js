import { shouldUseProxy as y } from "@scalar/oas-utils/helpers";
const w = () => {
  const e = new Uint8Array(32);
  return crypto.getRandomValues(e), btoa(String.fromCharCode(...e)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}, P = async (e, i) => {
  if (i === "plain")
    return e;
  const a = new TextEncoder().encode(e), s = await crypto.subtle.digest("SHA-256", a);
  return btoa(String.fromCharCode(...new Uint8Array(s))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}, C = async (e, i, o) => {
  try {
    if (!e)
      return [new Error("Flow not found"), null];
    const a = e.selectedScopes.join(" ");
    if (e.type === "clientCredentials" || e.type === "password")
      return _(e, a, {
        proxyUrl: o
      });
    const s = (Math.random() + 1).toString(36).substring(2, 10), t = new URL(e.authorizationUrl);
    let l = null;
    if (e.type === "implicit")
      t.searchParams.set("response_type", "token");
    else if (e.type === "authorizationCode" && (t.searchParams.set("response_type", "code"), e["x-usePkce"] !== "no")) {
      const r = w(), c = await P(r, e["x-usePkce"]);
      l = {
        codeVerifier: r,
        codeChallenge: c,
        codeChallengeMethod: e["x-usePkce"] === "SHA-256" ? "S256" : "plain"
      }, t.searchParams.set("code_challenge", c), t.searchParams.set("code_challenge_method", l.codeChallengeMethod);
    }
    if (e["x-scalar-redirect-uri"].startsWith("/")) {
      const r = i.url || window.location.origin + window.location.pathname, c = new URL(e["x-scalar-redirect-uri"], r).toString();
      t.searchParams.set("redirect_uri", c);
    } else
      t.searchParams.set("redirect_uri", e["x-scalar-redirect-uri"]);
    t.searchParams.set("client_id", e["x-scalar-client-id"]), t.searchParams.set("state", s), a && t.searchParams.set("scope", a);
    const n = window.open(t, "openAuth2Window", "left=100,top=100,width=800,height=600");
    return n ? new Promise((r) => {
      const c = setInterval(() => {
        var m;
        let u = null, h = null;
        try {
          const d = new URL(n.location.href).searchParams;
          u = d.get("access_token"), h = d.get("code");
          const g = new URLSearchParams(n.location.href.split("#")[1]);
          u || (u = g.get("access_token")), h || (h = g.get("code"));
        } catch {
        }
        if (n.closed || u || h)
          if (clearInterval(c), n.close(), u) {
            const d = (m = n.location.href.match(/state=([^&]*)/)) == null ? void 0 : m[1];
            r(d === s ? [null, u] : [new Error("State mismatch"), null]);
          } else h ? new URL(n.location.href).searchParams.get("state") === s ? _(e, a, {
            code: h,
            pkce: l,
            proxyUrl: o
          }).then(r) : r([new Error("State mismatch"), null]) : (clearInterval(c), r([new Error("Window was closed without granting authorization"), null]));
      }, 200);
    }) : [new Error("Failed to open auth window"), null];
  } catch {
    return [new Error("Failed to authorize oauth2 flow"), null];
  }
}, _ = async (e, i, {
  code: o,
  pkce: a,
  proxyUrl: s
} = {}) => {
  if (!e)
    return [new Error("OAuth2 flow was not defined"), null];
  const t = new URLSearchParams();
  t.set("client_id", e["x-scalar-client-id"]), i && (e.type === "clientCredentials" || e.type === "password") && t.set("scope", i), e.clientSecret && t.set("client_secret", e.clientSecret), "x-scalar-redirect-uri" in e && e["x-scalar-redirect-uri"] && t.set("redirect_uri", e["x-scalar-redirect-uri"]), o ? (t.set("code", o), t.set("grant_type", "authorization_code"), a && t.set("code_verifier", a.codeVerifier)) : e.type === "password" ? (t.set("grant_type", "password"), t.set("username", e.username), t.set("password", e.password)) : t.set("grant_type", "client_credentials");
  try {
    const l = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    e.clientSecret && (l.Authorization = `Basic ${btoa(`${e["x-scalar-client-id"]}:${e.clientSecret}`)}`);
    const p = y(s, e.tokenUrl) ? `${s}?${new URLSearchParams([["scalar_url", e.tokenUrl]]).toString()}` : e.tokenUrl, n = await fetch(p, {
      method: "POST",
      headers: l,
      body: t
    }), { access_token: r } = await n.json();
    return [null, r];
  } catch {
    return [new Error("Failed to get an access token. Please check your credentials."), null];
  }
};
export {
  C as authorizeOauth2,
  _ as authorizeServers,
  P as generateCodeChallenge
};
