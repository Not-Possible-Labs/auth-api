import { useActiveEntities as R } from "../../../store/active-entities.js";
import { specDictionary as f } from "../../../store/import-spec.js";
import { combineRenameDiffs as S, mutateCollectionDiff as d, mutateSecuritySchemeDiff as g, mutateServerDiff as D, mutateTagDiff as T, mutateRequestDiff as M } from "../libs/watch-mode.js";
import { fetchSpecFromUrl as I, createHash as U } from "@scalar/oas-utils/helpers";
import { parseSchema as O } from "@scalar/oas-utils/transforms";
import { useToasts as C } from "@scalar/use-toasts";
import { useTimeoutPoll as L } from "@vueuse/core";
import N from "microdiff";
import { watch as b } from "vue";
import { useWorkspace as P } from "../../../store/store.js";
const k = 5 * 1e3, q = 60 * 1e3, J = () => {
  const { toast: h } = C(), c = R(), o = P(), { activeCollection: t, activeWorkspace: W } = c, { collectionMutators: n } = o, r = (e) => h(`[useOpenApiWatcher] Changes to the ${e} were not applied`, "error"), w = (e) => {
    e.path[0] === "info" || e.path[0] === "security" ? d(e, c, o) || r("collection") : e.path[0] === "components" && e.path[1] === "securitySchemes" ? g(e, c, o) || r("securitySchemes") : e.path[0] === "servers" ? D(e, c, o) || r("servers") : e.path[0] === "tags" ? T(e, c, o) || r("tags") : e.path[0] === "paths" && (M(e, c, o) || r("requests"));
  }, { pause: p, resume: m } = L(async () => {
    var l, v;
    const e = (l = t.value) == null ? void 0 : l.documentUrl;
    if (!e)
      return;
    const s = f[e];
    try {
      const a = await I(e, (v = W.value) == null ? void 0 : v.proxyUrl, !1), u = U(a);
      if (n.edit(t.value.uid, "watchModeStatus", "WATCHING"), s != null && s.hash)
        if (s.hash && s.hash !== u) {
          const { schema: i } = await O(a), A = N(s.schema, i), y = S(A);
          try {
            y.forEach(w), f[e] = {
              hash: u,
              schema: i
            };
          } catch (E) {
            console.error("[useOpenApiWatcher] Error:", E);
          }
        } else
          console.log("[useOpenApiWatcher] No changes detected yet…");
      else {
        const { schema: i } = await O(a);
        i && (f[e] = {
          hash: u,
          schema: i
        });
      }
    } catch (a) {
      console.error("[useOpenApiWatcher] Error:", a), console.info("[useOpenApiWatcher] Pausing watcher for 60 seconds"), p(), n.edit(t.value.uid, "watchModeStatus", "ERROR"), h("[useOpenApiWatcher] Unable to fetch the spec file, paused the watcher for 60 seconds", "error"), setTimeout(() => {
        console.info("[useOpenApiWatcher] Resuming watcher"), m();
      }, q);
    }
  }, k);
  b(
    [() => {
      var e;
      return (e = t.value) == null ? void 0 : e.documentUrl;
    }, () => {
      var e;
      return (e = t.value) == null ? void 0 : e.watchMode;
    }],
    ([e, s]) => {
      e && s ? (console.info(`[useOpenApiWatcher] Watching ${e} …`), m()) : t.value && (p(), n.edit(t.value.uid, "watchModeStatus", "IDLE"));
    },
    { immediate: !0 }
  );
};
export {
  J as useOpenApiWatcher
};
