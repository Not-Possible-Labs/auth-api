import { isOperationDeprecated as F } from "../libs/operation.js";
import { ssrState as Y } from "@scalar/oas-utils/helpers";
import { ref as S, reactive as q, computed as J, watch as z } from "vue";
import { lazyBus as Z } from "../components/Content/Lazy/lazyBus.js";
import { useNavState as $ } from "./useNavState.js";
import { getLowestHeadingLevel as K } from "../helpers/getLowestHeadingLevel.js";
import { hasModels as ee } from "../helpers/hasModels.js";
import { getModels as P } from "../helpers/getModels.js";
import { hasWebhooks as te } from "../helpers/hasWebhooks.js";
import { getHeadingsFromMarkdown as se } from "../helpers/getHeadingsFromMarkdown.js";
import { scrollToId as R } from "../helpers/scrollToId.js";
const y = S(null), u = S(void 0), v = q({});
function _(t) {
  var p, r, i;
  v.tagsSorter === "alpha" ? t.tags = (p = t.tags) == null ? void 0 : p.sort((s, d) => s.name.localeCompare(d.name)) : typeof v.tagsSorter == "function" && (t.tags = (r = t.tags) == null ? void 0 : r.sort(v.tagsSorter));
  const a = (s, d) => {
    const x = s.name ?? s.path, g = d.name ?? d.path;
    return x.localeCompare(g);
  }, l = (s, d) => s.httpVerb.localeCompare(d.httpVerb);
  let c;
  return v.operationsSorter === "alpha" ? c = a : v.operationsSorter === "method" ? c = l : typeof v.operationsSorter == "function" && (c = v.operationsSorter), c && ((i = t.tags) == null || i.forEach((s) => {
    var d;
    s.operations = (d = s.operations) == null ? void 0 : d.sort(c);
  })), u.value = t;
}
const N = S(!1), Q = S(!1), T = q(Y["useSidebarContent-collapsedSidebarItems"] ?? {});
function re(t) {
  T[t] = !T[t];
}
function w(t, a) {
  T[t] = a;
}
const k = S([]);
function oe(t) {
  const a = se(t), l = K(a);
  return a.filter((c) => (
    // highest level, eg. # Introduction
    c.depth === l || // second highest level, eg. ## Authentication
    c.depth === l + 1
  ));
}
const U = J(() => {
  var C, H, B, E, j, V, D, G, L, W;
  if (!y.value)
    return { entries: [], titles: {} };
  const { getHeadingId: t, getModelId: a, getOperationId: l, getTagId: c, getWebhookId: p } = y.value, r = {}, i = [];
  let s = null;
  k.value.forEach((e) => {
    var o;
    e.depth === K(k.value) ? (s = {
      id: t(e),
      title: e.value,
      show: !0,
      children: []
    }, i.push(s)) : s && ((o = s.children) == null || o.push({
      id: t(e),
      title: e.value,
      show: !0
    }));
  });
  const d = (H = (C = u.value) == null ? void 0 : C.tags) == null ? void 0 : H[0], g = d && ((e) => (e == null ? void 0 : e.length) !== 1 || e[0].name !== "default" || e[0].description !== "")((B = u.value) == null ? void 0 : B.tags) ? (j = (E = u.value) == null ? void 0 : E.tags) == null ? void 0 : j.filter((e) => {
    var o;
    return ((o = e.operations) == null ? void 0 : o.length) > 0;
  }).map((e) => {
    var o;
    return {
      id: c(e),
      title: e.name,
      displayTitle: e["x-displayName"] ?? e.name,
      show: !0,
      children: (o = e.operations) == null ? void 0 : o.map((n) => {
        var m, b;
        const h = l(n, e), f = n.name ?? n.path;
        return r[h] = f, {
          id: h,
          title: f,
          httpVerb: n.httpVerb,
          // TODO: Workaround until we’re using the store directly
          deprecated: n.information ? F({
            deprecated: (m = n.information) == null ? void 0 : m.deprecated,
            "x-scalar-stability": (b = n.information) == null ? void 0 : b["x-scalar-stability"]
          }) : !1,
          show: !0,
          select: () => {
          }
        };
      })
    };
  }) : (V = d == null ? void 0 : d.operations) == null ? void 0 : V.map((e) => {
    var h, f;
    const o = l(e, d), n = e.name ?? e.path;
    return r[o] = n, {
      id: o,
      title: n,
      httpVerb: e.httpVerb,
      // TODO: Workaround until we’re using the store directly
      deprecated: e.information ? F({
        deprecated: (h = e.information) == null ? void 0 : h.deprecated,
        "x-scalar-stability": (f = e.information) == null ? void 0 : f["x-scalar-stability"]
      }) : !1,
      show: !0,
      select: () => {
      }
    };
  });
  let I = ee(u.value) && !N.value ? [
    {
      id: a(),
      title: "Models",
      show: !0,
      children: Object.keys(P(u.value) ?? {}).map((e) => {
        var n;
        const o = a({ name: e });
        return r[o] = e, {
          id: o,
          title: ((n = P(u.value)) == null ? void 0 : n[e]).title ?? e,
          show: !0
        };
      })
    }
  ] : [], O = te(u.value) ? [
    {
      id: p(),
      title: "Webhooks",
      show: !0,
      children: Object.keys(((D = u.value) == null ? void 0 : D.webhooks) ?? {}).flatMap((e) => {
        var n, h;
        const o = p({ name: e });
        return r[o] = e, Object.keys(((h = (n = u.value) == null ? void 0 : n.webhooks) == null ? void 0 : h[e]) ?? {}).map(
          (f) => {
            var m, b, A;
            return {
              id: p({ name: e, method: f }),
              title: (A = (b = (m = u.value) == null ? void 0 : m.webhooks) == null ? void 0 : b[e][f]) == null ? void 0 : A.name,
              httpVerb: f,
              show: !0
            };
          }
        );
      })
    }
  ] : [];
  const X = (G = u.value) != null && G["x-tagGroups"] ? (W = (L = u.value) == null ? void 0 : L["x-tagGroups"]) == null ? void 0 : W.map((e) => {
    var h;
    const o = [];
    return (h = e.tags) == null || h.map((f) => {
      if (f === "models" && I.length > 0)
        o.push(I[0]), I = [];
      else if (f === "webhooks" && O.length > 0)
        o.push(O[0]), O = [];
      else {
        const m = g == null ? void 0 : g.find((b) => b.title === f);
        m && o.push(m);
      }
    }), {
      id: e.name,
      title: e.name,
      children: o,
      show: !0,
      isGroup: !0
    };
  }) : void 0, M = [
    ...i,
    ...X ?? g ?? [],
    ...O,
    ...I
  ];
  return Q.value && M.forEach((e) => {
    w(e.id, !0), e.show = !0;
  }), {
    entries: M,
    titles: r
  };
}), ae = S(!1), le = J(() => {
  var t, a, l;
  return ((l = (t = U.value) == null ? void 0 : t.titles) == null ? void 0 : l[((a = y.value) == null ? void 0 : a.hash) ?? ""]) ?? "";
}), ie = (t, a) => {
  var c;
  const l = (c = y.value) == null ? void 0 : c.getSectionId(t);
  if (l && l !== t)
    if (T[l])
      R(t, a);
    else {
      const p = Z.on((r) => {
        r.id === t && (R(t, a), p());
      });
      w(l, !0);
    }
};
function Se(t) {
  Object.assign(v, t);
  const a = $();
  y.value = a;
  const { hash: l, getSectionId: c, getTagId: p } = a;
  return t != null && t.parsedSpec && (_(t.parsedSpec), z(
    () => {
      var r, i;
      return (i = (r = u.value) == null ? void 0 : r.tags) == null ? void 0 : i.length;
    },
    () => {
      var r, i;
      if (l.value) {
        const s = c(l.value);
        s && w(s, !0);
      } else {
        const s = (i = (r = u.value) == null ? void 0 : r.tags) == null ? void 0 : i[0];
        s && w(p(s), !0);
      }
    }
  ), z(
    () => {
      var r, i;
      return (i = (r = u.value) == null ? void 0 : r.info) == null ? void 0 : i.description;
    },
    () => {
      var i, s;
      const r = (s = (i = u.value) == null ? void 0 : i.info) == null ? void 0 : s.description;
      return r ? k.value = oe(r) : k.value = [];
    },
    {
      immediate: !0
    }
  )), {
    breadcrumb: le,
    items: U,
    isSidebarOpen: ae,
    collapsedSidebarItems: T,
    toggleCollapsedSidebarItem: re,
    setCollapsedSidebarItem: w,
    hideModels: N,
    setParsedSpec: _,
    defaultOpenAllTags: Q,
    scrollToOperation: ie
  };
}
export {
  ie as scrollToOperation,
  Se as useSidebar
};
