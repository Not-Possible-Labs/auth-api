import { isValidUrl as d, fetchSpecFromUrl as u, prettyPrintJson as h } from "@scalar/oas-utils/helpers";
import { ref as s, watch as m, toValue as p } from "vue";
import { parse as v } from "../helpers/parse.js";
import { createEmptySpecification as l } from "../helpers/createEmptySpecification.js";
const y = async ({ url: e, content: o }, n) => {
  if (e) {
    const i = performance.now();
    try {
      const c = d(e) ? await u(e, n) : await u(e), r = performance.now();
      return console.log(`fetch: ${Math.round(r - i)} ms (${e})`), console.log("size:", Math.round(c.length / 1024), "kB"), c;
    } catch (c) {
      console.error("Failed to fetch spec from URL:", c);
    }
  }
  const t = typeof o == "function" ? o() : o;
  if (typeof t == "string")
    return t;
  if (typeof t == "object")
    return h(t);
};
function E({
  specConfig: e,
  proxyUrl: o
}) {
  const n = s(""), t = s(l()), i = s(null);
  function c(r) {
    if (!r) {
      t.value = l();
      return;
    }
    v(r, {
      proxyUrl: o ? p(o) : void 0
    }).then((a) => {
      i.value = null, t.value = a;
    }).catch((a) => {
      i.value = a.toString();
    });
  }
  return m(
    () => p(e),
    async (r) => {
      var a;
      if (r) {
        const f = (a = await y(r, p(o))) == null ? void 0 : a.trim();
        typeof f == "string" && (n.value = f);
      }
    },
    { immediate: !0, deep: !0 }
  ), m(n, () => {
    c(n.value);
  }), {
    rawSpec: n,
    parsedSpec: t,
    specErrors: i
  };
}
export {
  E as useReactiveSpec
};
