import { isDefined as S } from "@scalar/oas-utils/helpers";
import { isConfigurationWithSources as m } from "@scalar/types/api-reference";
import h from "github-slugger";
import { computed as p, ref as y, watch as b } from "vue";
const w = "api", g = new h(), I = (l, a = 0) => {
  const e = {
    ...l,
    // @ts-expect-error this is before parsing so we transform the old style
    ...l.spec ?? {}
  };
  if (!(!(e != null && e.url) && !(e != null && e.content)))
    return g.reset(), e.title ? {
      ...e,
      slug: e.slug || g.slug(e.title),
      title: e.title
    } : e.slug ? {
      ...e,
      title: e.slug
    } : {
      ...e,
      slug: `api-${a + 1}`,
      title: `API #${a + 1}`
    };
}, P = ({
  configuration: l,
  initialIndex: a,
  isIntersectionEnabled: e,
  hash: c,
  hashPrefix: d
}) => {
  const r = p(() => l.value ? (m(l.value) ? (
    // This IFFE is needed for the type guard as it doens't persist into the callback scope
    (() => {
      const { sources: t, ...u } = l.value;
      return (t == null ? void 0 : t.map((n) => ({ ...u, ...n }))) ?? [];
    })()
  ) : [l.value].flat()).map((t, u) => t && I(t, u)).filter(S) : []), o = y((() => {
    if (typeof window > "u")
      return typeof a == "number" ? a : 0;
    const t = new URL(window.location.href).searchParams.get(w);
    if (t) {
      const n = r.value.findIndex((f) => f.slug === t);
      if (n !== -1)
        return n;
      const s = Number.parseInt(t, 10);
      if (!isNaN(s) && s >= 0 && s < r.value.length)
        return s;
    }
    const u = r.value.findIndex((n) => "default" in n && n.default === !0);
    return u !== -1 ? u : typeof a == "number" ? a : 0;
  })()), v = p(() => {
    var t, u;
    return l.value && m(l.value) ? {
      ...l.value,
      ...(u = (t = l.value) == null ? void 0 : t.sources) == null ? void 0 : u[o.value],
      ...r.value[o.value]
    } : {
      ...[l.value].flat()[o.value] ?? {},
      ...r.value[o.value]
    };
  });
  return b(
    o,
    (i) => {
      var s, f;
      if (typeof window > "u" || r.value.length === 1)
        return;
      const t = new URL(window.location.href), u = r.value[i], n = (u == null ? void 0 : u.slug) ?? i.toString();
      t.searchParams.set(w, n), t.hash = "", window.history.replaceState({}, "", t.toString()), c.value = "", d.value = "", e.value = !1, typeof window < "u" && window.scrollTo({ top: 0, behavior: "instant" }), (f = (s = v.value).onDocumentSelect) == null || f.call(s);
    },
    { flush: "sync" }
  ), {
    selectedConfiguration: v,
    availableDocuments: r,
    selectedDocumentIndex: o,
    isIntersectionEnabled: e,
    hash: c,
    hashPrefix: d
  };
};
export {
  P as useMultipleDocuments
};
