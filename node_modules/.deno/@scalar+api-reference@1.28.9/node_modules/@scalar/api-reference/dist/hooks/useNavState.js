import { useConfig as $ } from "./useConfig.js";
import { combineUrlAndPath as R } from "@scalar/oas-utils/helpers";
import { slug as l } from "github-slugger";
import { ref as i, inject as b } from "vue";
const y = Symbol(), U = i(!1), P = i(""), k = i(""), C = () => {
  const { isIntersectionEnabled: h, hash: r, hashPrefix: o } = b(y, {
    isIntersectionEnabled: U,
    hash: P,
    hashPrefix: k
  }), t = $(), c = (e) => {
    var n;
    if (!t.value.pathRouting)
      return "";
    const a = new RegExp("^" + ((n = t.value.pathRouting) == null ? void 0 : n.basePath) + "/?");
    return decodeURIComponent(e.replace(a, ""));
  }, d = (e = r.value) => {
    var g;
    const a = (g = e.match(/(tag\/[^/]+)/)) == null ? void 0 : g[0], n = e.startsWith("model") ? "models" : "", u = e.startsWith("webhook") ? "webhooks" : "";
    return a || n || u;
  }, f = () => {
    r.value = t.value.pathRouting ? c(window.location.pathname) : (
      // Must remove the prefix from the hash as the internal hash value should be pure
      decodeURIComponent(window.location.hash.replace(/^#/, "")).slice(o.value.length)
    );
  }, p = (e, a = window.location.href) => {
    const n = new URL(a);
    t.value.pathRouting ? n.pathname = R(t.value.pathRouting.basePath, e) : n.hash = o.value + e, r.value = e, window.history.replaceState({}, "", n);
  }, m = (e, a = window.location.href, n = window.location.search) => {
    const u = new URL(a);
    return u.hash = o.value + e, u.search = n, u.toString();
  }, v = (e = r.value) => `${o.value}${e}`, I = () => decodeURIComponent(window.location.hash.replace(/^#/, "").slice(o.value.length)), w = (e) => typeof t.value.generateHeadingSlug == "function" ? `${t.value.generateHeadingSlug(e)}` : e.slug ? `description/${e.slug}` : "", S = (e) => e != null && e.name ? typeof t.value.generateModelSlug == "function" ? `model/${t.value.generateModelSlug(e)}` : `model/${l(e.name)}` : "models", s = (e) => typeof t.value.generateTagSlug == "function" ? `tag/${t.value.generateTagSlug(e)}` : `tag/${l(e.name)}`;
  return {
    hash: r,
    /** Sets the prefix for the hash */
    setHashPrefix: (e) => {
      o.value = e;
    },
    /**
     * Gets the full hash with the prefix
     * @param hashTarget The hash to target with the return
     * @returns The full hash
     */
    getFullHash: v,
    /**
     * Gets the hashed url with the prefix
     * @param replacementHash The hash to replace the current hash with
     * @param url The url to get the hashed url from
     * @returns The hashed url
     */
    getHashedUrl: m,
    /**
     * Replaces the URL state with the new url and hash
     * Replacement is used so that hash changes don't trigger the url hash watcher and cause a scroll
     */
    replaceUrlState: p,
    /** Gets the portion of the hash used by the references */
    getReferenceHash: I,
    getWebhookId: (e) => e != null && e.name ? typeof t.value.generateWebhookSlug == "function" ? `webhook/${t.value.generateWebhookSlug(e)}` : `webhook/${e.method}/${l(e.name)}` : "webhooks",
    getModelId: S,
    getHeadingId: w,
    getOperationId: (e, a) => {
      var n;
      return typeof t.value.generateOperationSlug == "function" ? `${s(a)}/${t.value.generateOperationSlug({
        path: e.path,
        operationId: e.operationId,
        method: e.httpVerb,
        summary: (n = e.information) == null ? void 0 : n.summary
      })}` : `${s(a)}/${e.httpVerb}${e.path}`;
    },
    getPathRoutingId: c,
    getSectionId: d,
    getTagId: s,
    isIntersectionEnabled: h,
    updateHash: f
  };
};
export {
  y as NAV_STATE_SYMBOL,
  C as useNavState
};
