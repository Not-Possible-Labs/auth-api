import { defineComponent as D, ref as v, watch as E, onMounted as H, withDirectives as K, openBlock as l, createElementBlock as f, normalizeClass as M, Fragment as g, renderList as w, createBlock as m, unref as r, withCtx as d, createCommentVNode as T, createVNode as h, createTextVNode as j, toDisplayString as A, vShow as F } from "vue";
import { lazyBus as P } from "./lazyBus.js";
import q from "../Tag/TagSection.vue.js";
import G from "../../../features/Operation/Operation.vue.js";
import J from "../../Section/SectionContainer.vue.js";
import Q from "../../Section/Section.vue.js";
import R from "../../Section/SectionContent.vue.js";
import U from "../../Section/SectionHeader.vue.js";
import X from "../../Anchor/Anchor.vue.js";
import Y from "../../Section/SectionHeaderTag.vue.js";
import Z from "../Schema/Schema.vue.js";
import { useNavState as ee } from "../../../hooks/useNavState.js";
import { getModels as S } from "../../../helpers/getModels.js";
import { scrollToId as L } from "../../../helpers/scrollToId.js";
const ve = /* @__PURE__ */ D({
  __name: "Loading",
  props: {
    collection: {},
    server: {},
    layout: { default: "modern" },
    parsedSpec: {}
  },
  setup(O) {
    const i = O, C = v(!1), y = v([]), I = v([]), { getModelId: V, getSectionId: z, getTagId: B, hash: a, isIntersectionEnabled: b } = ee(), _ = v(i.layout !== "classic" && a.value);
    E(
      () => {
        var t;
        return (t = i.parsedSpec.tags) == null ? void 0 : t.length;
      },
      (t) => {
        var e, u;
        if (!a.value || typeof t != "number" || !i.parsedSpec.tags)
          return;
        const n = z();
        if (n.startsWith("tag")) {
          let o = 0;
          const c = ((e = i.parsedSpec.tags) == null ? void 0 : e.findIndex(
            (k) => B(k) === n
          )) ?? 0, s = a.value.match(/tag\/([^/]+)\/([^/]+)\/(.+)/);
          if ((s == null ? void 0 : s.length) === 4) {
            const k = s[2], W = "/" + s[3];
            o = (u = i.parsedSpec.tags[c]) == null ? void 0 : u.operations.findIndex(
              ({ httpVerb: $, path: x }) => k === $ && W === x
            );
          }
          const p = i.parsedSpec.tags[c];
          if (!p)
            return;
          p.name !== "default" && (C.value = n !== a.value && n.startsWith("tag")), y.value.push({
            ...p,
            lazyOperations: p.operations.slice(
              o,
              o + 2
            )
          });
        } else if (a.value.startsWith("model")) {
          const o = Object.keys(S(i.parsedSpec) ?? {}), [, c] = a.value.toLowerCase().split("/"), s = a.value === "models" ? 0 : o.findIndex((p) => p.toLowerCase() === c);
          if (s === -1)
            return;
          I.value = o.slice(s, s + 3);
        } else
          typeof window < "u" && L(a.value), setTimeout(() => b.value = !0, 1e3);
      },
      { immediate: !0 }
    );
    const N = P.on(({ id: t }) => {
      const n = a.value;
      !n || t !== n || (N(), setTimeout(() => {
        typeof window < "u" && L(n), _.value = !1, setTimeout(() => b.value = !0, 1e3);
      }, 300));
    });
    return H(() => {
      a.value || setTimeout(() => b.value = !0, 1e3);
    }), (t, n) => K((l(), f("div", {
      class: M(["references-loading", {
        "references-loading-hidden-tag": C.value,
        "references-loading-top-spacer": y.value.length
      }])
    }, [
      (l(!0), f(g, null, w(y.value, (e, u) => (l(), f(g, {
        key: e.name + u
      }, [
        e.operations && e.operations.length > 0 ? (l(), m(r(q), {
          key: 0,
          collection: t.collection,
          spec: t.parsedSpec,
          tag: e
        }, {
          default: d(() => [
            (l(!0), f(g, null, w(e.lazyOperations, (o) => (l(), m(r(G), {
              key: `${o.httpVerb}-${o.operationId}`,
              collection: t.collection,
              layout: t.layout,
              server: t.server,
              transformedOperation: o
            }, null, 8, ["collection", "layout", "server", "transformedOperation"]))), 128))
          ]),
          _: 2
        }, 1032, ["collection", "spec", "tag"])) : T("", !0)
      ], 64))), 128)),
      I.value.length ? (l(), m(r(J), { key: 0 }, {
        default: d(() => [
          (l(!0), f(g, null, w(I.value, (e) => (l(), m(r(Q), {
            key: e,
            label: e
          }, {
            default: d(() => {
              var u;
              return [
                (u = r(S)(t.parsedSpec)) != null && u[e] ? (l(), m(r(R), { key: 0 }, {
                  default: d(() => {
                    var o;
                    return [
                      h(r(U), null, {
                        default: d(() => [
                          h(r(X), {
                            id: r(V)({ name: e })
                          }, {
                            default: d(() => [
                              h(r(Y), { level: 2 }, {
                                default: d(() => {
                                  var c;
                                  return [
                                    j(A(((c = r(S)(t.parsedSpec)) == null ? void 0 : c[e]).title ?? e), 1)
                                  ];
                                }),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1032, ["id"])
                        ]),
                        _: 2
                      }, 1024),
                      h(r(Z), {
                        name: e,
                        noncollapsible: "",
                        value: (o = r(S)(t.parsedSpec)) == null ? void 0 : o[e]
                      }, null, 8, ["name", "value"])
                    ];
                  }),
                  _: 2
                }, 1024)) : T("", !0)
              ];
            }),
            _: 2
          }, 1032, ["label"]))), 128))
        ]),
        _: 1
      })) : T("", !0)
    ], 2)), [
      [F, _.value]
    ]);
  }
});
export {
  ve as default
};
