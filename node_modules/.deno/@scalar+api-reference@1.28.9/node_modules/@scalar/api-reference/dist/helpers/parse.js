import { redirectToProxy as R, shouldIgnoreEntity as u } from "@scalar/oas-utils/helpers";
import { load as M, dereference as q } from "@scalar/openapi-parser";
import { fetchUrls as D } from "@scalar/openapi-parser/plugins/fetch-urls";
import { createEmptySpecification as O } from "./createEmptySpecification.js";
import { normalizeRequestMethod as j } from "../legacy/helpers/normalizeRequestMethod.js";
import { validRequestMethods as C } from "../legacy/fixtures/httpRequestMethods.js";
const G = (m, {
  proxyUrl: e
} = {}) => new Promise(async (n, b) => {
  var h;
  try {
    if (!m)
      return n(I(O()));
    const f = performance.now(), { filesystem: s } = await M(m, {
      plugins: [
        D({
          fetch: (o) => fetch(e ? R(e, o) : o)
        })
      ]
    }), { schema: a, errors: r } = await q(s), t = performance.now();
    return console.log(`dereference: ${Math.round(t - f)} ms`), r != null && r.length && console.warn(
      `Please open an issue on https://github.com/scalar/scalar
`,
      `Scalar OpenAPI Parser Warning:
`,
      r
    ), a === void 0 ? (b(((h = r == null ? void 0 : r[0]) == null ? void 0 : h.message) ?? "Failed to parse the OpenAPI file."), n(I(O()))) : n(I(a));
  } catch (f) {
    console.error("[@scalar/api-reference]", "Failed to parse the OpenAPI document. It might be invalid?"), console.error(f), b(f);
  }
  return n(I(O()));
}), I = (m) => {
  var h, f;
  let e = {};
  m && typeof m == "object" ? e = structuredClone(m) : e = O(), e.tags || (e.tags = []), e.paths || (e.paths = {}), e.components || (e.components = {}), e.webhooks || (e.webhooks = {}), e.servers || (e.servers = []), e.security || (e.security = []), e.externalDocs || (e.externalDocs = {});
  const n = {};
  return Object.keys(e.webhooks ?? {}).forEach((s) => {
    var a;
    Object.keys(((a = e.webhooks) == null ? void 0 : a[s]) ?? {}).forEach((r) => {
      var o, l, g, y;
      const t = (o = e.webhooks) == null ? void 0 : o[s][r];
      if (!(!t || u(t))) {
        if (Array.isArray(t.tags)) {
          const i = (l = t.tags) == null ? void 0 : l.map(
            (c) => {
              var w;
              return (w = e.tags) == null ? void 0 : w.find((p) => p.name === c);
            }
          );
          if (t.tags = i == null ? void 0 : i.filter((c) => !u(c)), i != null && i.some((c) => u(c)))
            return;
        }
        n[s] === void 0 && (n[s] = {}), n[s][r] = {
          // Transformed data
          httpVerb: j(r),
          path: s,
          operationId: (t == null ? void 0 : t.operationId) || s,
          name: (t == null ? void 0 : t.summary) || s || "",
          description: (t == null ? void 0 : t.description) || "",
          pathParameters: (y = (g = e.paths) == null ? void 0 : g[s]) == null ? void 0 : y.parameters,
          // Original webhook
          information: {
            ...t
          }
        };
      }
    });
  }), Object.keys(((h = e.components) == null ? void 0 : h.schemas) ?? {}).forEach((s) => {
    var a, r, t, o;
    u((r = (a = e.components) == null ? void 0 : a.schemas) == null ? void 0 : r[s]) && ((o = (t = e.components) == null ? void 0 : t.schemas) == null || delete o[s]);
  }), Object.keys(e.paths).forEach((s) => {
    Object.keys(e.paths[s]).filter(
      (r) => C.includes(r.toUpperCase())
    ).forEach((r) => {
      var l, g, y, i, c, w;
      const t = e.paths[s][r];
      if (t === void 0 || u(t))
        return;
      const o = {
        httpVerb: j(r),
        path: s,
        operationId: t.operationId || s,
        name: t.summary || s || "",
        description: t.description || "",
        information: {
          ...t
        },
        pathParameters: (g = (l = e.paths) == null ? void 0 : l[s]) == null ? void 0 : g.parameters
      };
      if (!t.tags || t.tags.length === 0) {
        (y = e.tags) != null && y.find((d) => d.name === "default") || (i = e.tags) == null || i.push({
          name: "default",
          description: "",
          operations: []
        });
        const p = (c = e.tags) == null ? void 0 : c.findIndex(
          (d) => d.name === "default"
        );
        p >= 0 && ((w = e.tags[p]) == null || w.operations.push(o));
      } else
        t.tags.forEach((p) => {
          var E, P, k;
          const d = (E = e.tags) == null ? void 0 : E.findIndex((A) => A.name === p);
          d === -1 && ((P = e.tags) == null || P.push({
            name: p,
            description: ""
          }));
          const x = d !== -1 ? d : e.tags.length - 1;
          typeof ((k = e.tags[x]) == null ? void 0 : k.operations) > "u" && (e.tags[x].operations = []), e.tags[x].operations.push(o);
        });
    });
  }), e.tags = (f = e.tags) == null ? void 0 : f.filter((s) => !u(s)), {
    ...e,
    webhooks: n
  };
};
export {
  G as parse
};
